// Code generated by capnpc-go. DO NOT EDIT.

package types

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type Block capnp.Struct

// Block_TypeID is the unique identifier for the type Block.
const Block_TypeID = 0xa67ef24ada1537dd

func NewBlock(s *capnp.Segment) (Block, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 10})
	return Block(st), err
}

func NewRootBlock(s *capnp.Segment) (Block, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 10})
	return Block(st), err
}

func ReadRootBlock(msg *capnp.Message) (Block, error) {
	root, err := msg.Root()
	return Block(root.Struct()), err
}

func (s Block) String() string {
	str, _ := text.Marshal(0xa67ef24ada1537dd, capnp.Struct(s))
	return str
}

func (s Block) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Block) DecodeFromPtr(p capnp.Ptr) Block {
	return Block(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Block) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Block) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Block) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Block) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Block) Hash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Block) HasHash() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Block) SetHash(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Block) ParentHash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Block) HasParentHash() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Block) SetParentHash(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s Block) Height() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Block) SetHeight(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s Block) Miner() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return []byte(p.Data()), err
}

func (s Block) HasMiner() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Block) SetMiner(v []byte) error {
	return capnp.Struct(s).SetData(2, v)
}

func (s Block) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Block) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s Block) GasLimit() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s Block) HasGasLimit() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Block) SetGasLimit(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

func (s Block) GasUsed() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return []byte(p.Data()), err
}

func (s Block) HasGasUsed() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Block) SetGasUsed(v []byte) error {
	return capnp.Struct(s).SetData(4, v)
}

func (s Block) LogsBloom() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return []byte(p.Data()), err
}

func (s Block) HasLogsBloom() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Block) SetLogsBloom(v []byte) error {
	return capnp.Struct(s).SetData(5, v)
}

func (s Block) TransactionsRoot() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return []byte(p.Data()), err
}

func (s Block) HasTransactionsRoot() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s Block) SetTransactionsRoot(v []byte) error {
	return capnp.Struct(s).SetData(6, v)
}

func (s Block) ReceiptsRoot() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(7)
	return []byte(p.Data()), err
}

func (s Block) HasReceiptsRoot() bool {
	return capnp.Struct(s).HasPtr(7)
}

func (s Block) SetReceiptsRoot(v []byte) error {
	return capnp.Struct(s).SetData(7, v)
}

func (s Block) StateRoot() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(8)
	return []byte(p.Data()), err
}

func (s Block) HasStateRoot() bool {
	return capnp.Struct(s).HasPtr(8)
}

func (s Block) SetStateRoot(v []byte) error {
	return capnp.Struct(s).SetData(8, v)
}

func (s Block) Size() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(9)
	return []byte(p.Data()), err
}

func (s Block) HasSize() bool {
	return capnp.Struct(s).HasPtr(9)
}

func (s Block) SetSize(v []byte) error {
	return capnp.Struct(s).SetData(9, v)
}

// Block_List is a list of Block.
type Block_List = capnp.StructList[Block]

// NewBlock creates a new list of Block.
func NewBlock_List(s *capnp.Segment, sz int32) (Block_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 10}, sz)
	return capnp.StructList[Block](l), err
}

// Block_Future is a wrapper for a Block promised by a client call.
type Block_Future struct{ *capnp.Future }

func (p Block_Future) Struct() (Block, error) {
	s, err := p.Future.Struct()
	return Block(s), err
}

type Filter capnp.Struct

// Filter_TypeID is the unique identifier for the type Filter.
const Filter_TypeID = 0xb37037e086845aa0

func NewFilter(s *capnp.Segment) (Filter, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 7})
	return Filter(st), err
}

func NewRootFilter(s *capnp.Segment) (Filter, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 7})
	return Filter(st), err
}

func ReadRootFilter(msg *capnp.Message) (Filter, error) {
	root, err := msg.Root()
	return Filter(root.Struct()), err
}

func (s Filter) String() string {
	str, _ := text.Marshal(0xb37037e086845aa0, capnp.Struct(s))
	return str
}

func (s Filter) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Filter) DecodeFromPtr(p capnp.Ptr) Filter {
	return Filter(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Filter) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Filter) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Filter) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Filter) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Filter) Type() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Filter) HasType() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Filter) TypeBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Filter) SetType(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Filter) CreatedBy() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Filter) HasCreatedBy() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Filter) CreatedByBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Filter) SetCreatedBy(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Filter) PollBlock() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return []byte(p.Data()), err
}

func (s Filter) HasPollBlock() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Filter) SetPollBlock(v []byte) error {
	return capnp.Struct(s).SetData(2, v)
}

func (s Filter) FromBlock() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s Filter) HasFromBlock() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Filter) SetFromBlock(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

func (s Filter) ToBlock() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return []byte(p.Data()), err
}

func (s Filter) HasToBlock() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Filter) SetToBlock(v []byte) error {
	return capnp.Struct(s).SetData(4, v)
}

func (s Filter) Addresses() (capnp.DataList, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return capnp.DataList(p.List()), err
}

func (s Filter) HasAddresses() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Filter) SetAddresses(v capnp.DataList) error {
	return capnp.Struct(s).SetPtr(5, v.ToPtr())
}

// NewAddresses sets the addresses field to a newly
// allocated capnp.DataList, preferring placement in s's segment.
func (s Filter) NewAddresses(n int32) (capnp.DataList, error) {
	l, err := capnp.NewDataList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.DataList{}, err
	}
	err = capnp.Struct(s).SetPtr(5, l.ToPtr())
	return l, err
}

func (s Filter) Topics() (capnp.PointerList, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return capnp.PointerList(p.List()), err
}

func (s Filter) HasTopics() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s Filter) SetTopics(v capnp.PointerList) error {
	return capnp.Struct(s).SetPtr(6, v.ToPtr())
}

// NewTopics sets the topics field to a newly
// allocated capnp.PointerList, preferring placement in s's segment.
func (s Filter) NewTopics(n int32) (capnp.PointerList, error) {
	l, err := capnp.NewPointerList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.PointerList{}, err
	}
	err = capnp.Struct(s).SetPtr(6, l.ToPtr())
	return l, err
}

// Filter_List is a list of Filter.
type Filter_List = capnp.StructList[Filter]

// NewFilter creates a new list of Filter.
func NewFilter_List(s *capnp.Segment, sz int32) (Filter_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 7}, sz)
	return capnp.StructList[Filter](l), err
}

// Filter_Future is a wrapper for a Filter promised by a client call.
type Filter_Future struct{ *capnp.Future }

func (p Filter_Future) Struct() (Filter, error) {
	s, err := p.Future.Struct()
	return Filter(s), err
}

type Transaction capnp.Struct

// Transaction_TypeID is the unique identifier for the type Transaction.
const Transaction_TypeID = 0xedb7a741ddfe927d

func NewTransaction(s *capnp.Segment) (Transaction, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 16})
	return Transaction(st), err
}

func NewRootTransaction(s *capnp.Segment) (Transaction, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 16})
	return Transaction(st), err
}

func ReadRootTransaction(msg *capnp.Message) (Transaction, error) {
	root, err := msg.Root()
	return Transaction(root.Struct()), err
}

func (s Transaction) String() string {
	str, _ := text.Marshal(0xedb7a741ddfe927d, capnp.Struct(s))
	return str
}

func (s Transaction) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Transaction) DecodeFromPtr(p capnp.Ptr) Transaction {
	return Transaction(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Transaction) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Transaction) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Transaction) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Transaction) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Transaction) Hash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Transaction) HasHash() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Transaction) SetHash(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Transaction) BlockHash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Transaction) HasBlockHash() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Transaction) SetBlockHash(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s Transaction) BlockHeight() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Transaction) SetBlockHeight(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s Transaction) TransactionIndex() uint32 {
	return capnp.Struct(s).Uint32(8)
}

func (s Transaction) SetTransactionIndex(v uint32) {
	capnp.Struct(s).SetUint32(8, v)
}

func (s Transaction) From() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return []byte(p.Data()), err
}

func (s Transaction) HasFrom() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Transaction) SetFrom(v []byte) error {
	return capnp.Struct(s).SetData(2, v)
}

func (s Transaction) To() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s Transaction) HasTo() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Transaction) SetTo(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

func (s Transaction) Nonce() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return []byte(p.Data()), err
}

func (s Transaction) HasNonce() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Transaction) SetNonce(v []byte) error {
	return capnp.Struct(s).SetData(4, v)
}

func (s Transaction) GasPrice() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return []byte(p.Data()), err
}

func (s Transaction) HasGasPrice() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Transaction) SetGasPrice(v []byte) error {
	return capnp.Struct(s).SetData(5, v)
}

func (s Transaction) GasLimit() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return []byte(p.Data()), err
}

func (s Transaction) HasGasLimit() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s Transaction) SetGasLimit(v []byte) error {
	return capnp.Struct(s).SetData(6, v)
}

func (s Transaction) GasUsed() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(7)
	return []byte(p.Data()), err
}

func (s Transaction) HasGasUsed() bool {
	return capnp.Struct(s).HasPtr(7)
}

func (s Transaction) SetGasUsed(v []byte) error {
	return capnp.Struct(s).SetData(7, v)
}

func (s Transaction) Value() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(8)
	return []byte(p.Data()), err
}

func (s Transaction) HasValue() bool {
	return capnp.Struct(s).HasPtr(8)
}

func (s Transaction) SetValue(v []byte) error {
	return capnp.Struct(s).SetData(8, v)
}

func (s Transaction) Input() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(9)
	return []byte(p.Data()), err
}

func (s Transaction) HasInput() bool {
	return capnp.Struct(s).HasPtr(9)
}

func (s Transaction) SetInput(v []byte) error {
	return capnp.Struct(s).SetData(9, v)
}

func (s Transaction) Output() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(10)
	return []byte(p.Data()), err
}

func (s Transaction) HasOutput() bool {
	return capnp.Struct(s).HasPtr(10)
}

func (s Transaction) SetOutput(v []byte) error {
	return capnp.Struct(s).SetData(10, v)
}

func (s Transaction) Status() bool {
	return capnp.Struct(s).Bit(96)
}

func (s Transaction) SetStatus(v bool) {
	capnp.Struct(s).SetBit(96, v)
}

func (s Transaction) ContractAddress() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(11)
	return []byte(p.Data()), err
}

func (s Transaction) HasContractAddress() bool {
	return capnp.Struct(s).HasPtr(11)
}

func (s Transaction) SetContractAddress(v []byte) error {
	return capnp.Struct(s).SetData(11, v)
}

func (s Transaction) V() uint64 {
	return capnp.Struct(s).Uint64(16)
}

func (s Transaction) SetV(v uint64) {
	capnp.Struct(s).SetUint64(16, v)
}

func (s Transaction) R() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(12)
	return []byte(p.Data()), err
}

func (s Transaction) HasR() bool {
	return capnp.Struct(s).HasPtr(12)
}

func (s Transaction) SetR(v []byte) error {
	return capnp.Struct(s).SetData(12, v)
}

func (s Transaction) S() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(13)
	return []byte(p.Data()), err
}

func (s Transaction) HasS() bool {
	return capnp.Struct(s).HasPtr(13)
}

func (s Transaction) SetS(v []byte) error {
	return capnp.Struct(s).SetData(13, v)
}

func (s Transaction) NearHash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(14)
	return []byte(p.Data()), err
}

func (s Transaction) HasNearHash() bool {
	return capnp.Struct(s).HasPtr(14)
}

func (s Transaction) SetNearHash(v []byte) error {
	return capnp.Struct(s).SetData(14, v)
}

func (s Transaction) NearReceiptHash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(15)
	return []byte(p.Data()), err
}

func (s Transaction) HasNearReceiptHash() bool {
	return capnp.Struct(s).HasPtr(15)
}

func (s Transaction) SetNearReceiptHash(v []byte) error {
	return capnp.Struct(s).SetData(15, v)
}

// Transaction_List is a list of Transaction.
type Transaction_List = capnp.StructList[Transaction]

// NewTransaction creates a new list of Transaction.
func NewTransaction_List(s *capnp.Segment, sz int32) (Transaction_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 16}, sz)
	return capnp.StructList[Transaction](l), err
}

// Transaction_Future is a wrapper for a Transaction promised by a client call.
type Transaction_Future struct{ *capnp.Future }

func (p Transaction_Future) Struct() (Transaction, error) {
	s, err := p.Future.Struct()
	return Transaction(s), err
}

type Log capnp.Struct

// Log_TypeID is the unique identifier for the type Log.
const Log_TypeID = 0xbd3a21c2edbb01d9

func NewLog(s *capnp.Segment) (Log, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 8})
	return Log(st), err
}

func NewRootLog(s *capnp.Segment) (Log, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 8})
	return Log(st), err
}

func ReadRootLog(msg *capnp.Message) (Log, error) {
	root, err := msg.Root()
	return Log(root.Struct()), err
}

func (s Log) String() string {
	str, _ := text.Marshal(0xbd3a21c2edbb01d9, capnp.Struct(s))
	return str
}

func (s Log) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Log) DecodeFromPtr(p capnp.Ptr) Log {
	return Log(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Log) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Log) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Log) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Log) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Log) Removed() bool {
	return capnp.Struct(s).Bit(0)
}

func (s Log) SetRemoved(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

func (s Log) LogIndex() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Log) HasLogIndex() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Log) SetLogIndex(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Log) TransactionIndex() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Log) HasTransactionIndex() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Log) SetTransactionIndex(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s Log) TransactionHash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return []byte(p.Data()), err
}

func (s Log) HasTransactionHash() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Log) SetTransactionHash(v []byte) error {
	return capnp.Struct(s).SetData(2, v)
}

func (s Log) BlockHash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s Log) HasBlockHash() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Log) SetBlockHash(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

func (s Log) BlockNumber() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return []byte(p.Data()), err
}

func (s Log) HasBlockNumber() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Log) SetBlockNumber(v []byte) error {
	return capnp.Struct(s).SetData(4, v)
}

func (s Log) Address() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return []byte(p.Data()), err
}

func (s Log) HasAddress() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Log) SetAddress(v []byte) error {
	return capnp.Struct(s).SetData(5, v)
}

func (s Log) Data() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return []byte(p.Data()), err
}

func (s Log) HasData() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s Log) SetData(v []byte) error {
	return capnp.Struct(s).SetData(6, v)
}

func (s Log) Topics() (capnp.DataList, error) {
	p, err := capnp.Struct(s).Ptr(7)
	return capnp.DataList(p.List()), err
}

func (s Log) HasTopics() bool {
	return capnp.Struct(s).HasPtr(7)
}

func (s Log) SetTopics(v capnp.DataList) error {
	return capnp.Struct(s).SetPtr(7, v.ToPtr())
}

// NewTopics sets the topics field to a newly
// allocated capnp.DataList, preferring placement in s's segment.
func (s Log) NewTopics(n int32) (capnp.DataList, error) {
	l, err := capnp.NewDataList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.DataList{}, err
	}
	err = capnp.Struct(s).SetPtr(7, l.ToPtr())
	return l, err
}

// Log_List is a list of Log.
type Log_List = capnp.StructList[Log]

// NewLog creates a new list of Log.
func NewLog_List(s *capnp.Segment, sz int32) (Log_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 8}, sz)
	return capnp.StructList[Log](l), err
}

// Log_Future is a wrapper for a Log promised by a client call.
type Log_Future struct{ *capnp.Future }

func (p Log_Future) Struct() (Log, error) {
	s, err := p.Future.Struct()
	return Log(s), err
}

const schema_85d3acc39d94e0f8 = "x\xda\x8c\x95_h\x14\xe7\x1a\xc6\x9f\xe7\x9b\xd9\xec&" +
	"f\xb3Yg\x02r\xf0\x10\x05\x03\x079\x9e\xa3\x15Q" +
	"\x82\xa0Y\xb4\xac\x12K&\x93\x80\x88B&\xbb\xd3\xdd" +
	"\xa9\xbb;\xdb\x9d\x89h\xd1\xc6\x96XDZ*\xc5\x8b" +
	"\xde\x14zUozQ(\xa5-m\xa1\xff\xa0\x7f\xf0" +
	"\xa6\xd4B+\x08\xd2\xab\xde\x04li\xa1\x05\xdb-\xef" +
	"\xb7fv\"\x0a\xbdJ\xf2\xfb\xde\xef\x9d\x99\xf7}\x9e" +
	"';;\xc6AsW\xfe\x0b\x05\xe5l\xc9\x0cto" +
	"\xef\x1d\xbbu\xf4\x97g\xdf\x803F\xd5\xfd\xfd\xce\xb5" +
	"\xd7>{\xf3\xdbK\xc8\x0ce\x01\xeb\x08oY\xf3\xcc" +
	"\x02\xbb\x1d^W`\xf7\xf5\x13+/\xdc\xd9\xdb~\x1b" +
	"\xc51\xa6\x8a\xb3R<a\xfeh\xed2\xa5x\x87\xf9" +
	"2\xc1\xee\x0f\xfc`\xf5\xd3\xad\x93\x1fI\xebtuN" +
	"\xaa\x7f\xcb|mq@\xaa\xff\xcct\xa5\xfa\xc2+\x7f" +
	"\xdd\x9e\xba\xfe\xee\xaaT\x1b\xa9\xeaQ\xa9\x99\xc8\x0d\xd1" +
	"\xda#\x17w\xef\xca\xd5L\xec\xe8V\x17\xff\x1f\x9fk" +
	"\xfb\x91\xea\xfd\xf8_\xc5k\xb7\xda\x93\xa5FhTN" +
	"\xcf\x90\xceN\xc3\x04L\x02\xd6\x14\xb7\x03\xee~\x1at" +
	"\xcbT,\x926\x85\x1f\xe6\x09\xc0=$|\x86\x8aT" +
	"6\x15`\x1d\xe3$\xe0\x96\x05\xcfI\xb9\xa1l\x1a\x80" +
	"\xe5\xf01\xc0\x9d\x16~\\\xb8I\x9b&`\xcds\x16" +
	"p\xe7\x84/\x08\xcf\x1863\x80u\x8aG\x01\xf7\xa4" +
	"\xf0\xba\xf0\x01\xd3\xe6\x00`\xf9,\x01\xee\x82\xf0\x86\xf0" +
	"l\xc6\x96\x09[\x81\xeeS\x17\x1e\x0b\xcf\x0d\xd8\xcc\x01" +
	"\xd6\xd3\xbc\x02\xb8\xb1\xf0\x8b\xc2\x07\xb36\x07\x01\xeb\x02" +
	"\x9f\x02\xdc\xf3\xc2/\x0b\x1f\xca\xd9\x1c\x02\xacK\xba\xcf" +
	"\x8a\xf0\xab\xc27\x0c\xda\xdc\x00X/\xe91\\\x16~" +
	"\x8d\x8a\x85\xba\x17\xd5\x99\x87b\x1e\xec\xb6\xbd\x8e\xdf\x8a" +
	"\xcb\x1e\x8c><P\xf7\x83Z=\xe6 \x14\x07\xc1\xf1" +
	"f\xd0\xf2;\xc9\x8d8h\xfaQ\xec5\xc163P" +
	"\xcc\x80\xdd\x9a\x17M\x07\xcd \x06\xb0V\xb7\\\xf3\xa2" +
	"\xf9\xc8\xaf&\xf7\x1aa-*5\xc2\x10l\xf6{u" +
	"\xbcV\xe4Ub\x06a+\x9a\x0d\xc3\xb8\x7f\xbf\xdb\xf1" +
	"+~\xd0\x8e#\x14\xe4 \xc1Q\xec\xc5\xfe\xac\xb4I" +
	"X!\x0a\x9e\xf1\x93\x82\x87\xeb\xe3\xf1\xa0\x91\x8d\xfd\x8e" +
	"\x08d\xf3\x9a@\x8a\xefl\x07\x9c\xb7\x0c:\x1f\xf6\xd5" +
	"Q|\x7f\x16p\xde3\xe8|\xaeXT=m\x14?" +
	"\x11\xf8\xb1A\xe7\x86\x08\xc3\xd0\xc2(~%\xf0K\x83" +
	"\xceMQ\x85\xa9UQ\xfc\xa6\x0487\x0c:\xdf\x8b" +
	"$2Z\x12\xc5\xef\xa4\xf2\xa6A\xe7\xae\xe8a@\xeb" +
	"\xa1\xb8:\x098?\x19tm\xd9\x8a\xbc,\x87\xa18" +
	"\x0cv+\x1d\xdf\x8b\xfdj\x09<\x97\xb0v\xd8h\x94" +
	"\x1aa\x05<\x9d|\xeb\x93\x9d\xb0\xf9\x00[\x8eC!" +
	"\xfd\x1a\xafZ\xed\xf8Q\xe4\x83\x11G\xc0\x19\x83\xfah" +
	"\x04<\x10\x87\xed\xa0\x92\xd0\xf5\x87\x8f\x98\xe3tX\x03" +
	"d\x8a\xdb\x92)\xae\x96z\xdf\xe1\xfc\xaa\xb86\xc4\x9f" +
	"\x8f\x02\xce]\x83\xce=\x19\"{C\xfc\xe3\x0a\xe0\xdc" +
	"3\xe8\xe6\xd2\xf6\xca\xf0y\xc05E\x9e\xa3\xda^F" +
	"\xcf^y-\xe7a\xe1\x9b\xb4\xbd\xcc\x9e\xbd\xc6\xb8\x08" +
	"\xb8\xb6\xf0-\xda^\x99\x9e\xbd\xfe\xad\xed\xb5I\xf86" +
	"m\xaf\x81\x9e\xbd\xb6j\xf9o\x16\xfe\x1fm\xafl\xcf" +
	"^\x13\xda\xee[\x84\xef\xa7\xe2r\xc7o\x86g\xfc*" +
	"\x09E\xf6\xf4z\xa4U\xf5\xcf\xa64\xbdN\xaf\xf7\x0f" +
	"\x1fzV\xf6\xa2z\xffdQ\xf6Q\xf6\"\xb0\xbe\x9e" +
	"=\xb1\xd4Dv\xb1\xef\xad\xe5\xfb\xbbJ\x84]\xf5b" +
	"/q\xe5\xfam=\xb8&c\xdd\x9a\xe6\xee\xbfL\x10" +
	"\xb6z\xeb\x9aIRq\xab\xd2\xf3P2\x0f\x95J\xc5" +
	"\x09%\xf3\xde&|\xa7\xea\xa7\xe2\x0e%\xe3\xfe\xaf\xe0" +
	"}*\xb5\xb6=J\xd2i\x9f\xf0C\xc2M\xd5[\xdb" +
	"\x94n\xbf_xY\xa5R\xf1\xb0\xfa\x17\xe0\x1e\x14>" +
	"\xadR\xa9xDI\xba\x1e\x12>\xa3R\xa9xLI" +
	"\x8aN\x0b?\xaeR\xa98\xaf\xf9\x9c\xf0\x05\x95J\xc5" +
	"SJ\xd6\x7f\\xU\xa5R\xd1\xd3\xfdO\x0a\xaf\xab" +
	"T*\xfa\x9a/\x08o\x08\x1f\x1e\xb29,i\xacD" +
	"\x16U\xe1m\xe1\xf9\x05\x9by\xc0jj^\x17\x1e\x0b" +
	"\x1f\xd9`sDRZ\x89|\xdb\xc2\xcf\x0b/(\x9b" +
	"\x05\xc0:\xa76Jz\x0b\xbf(|t\xd8\xe6\xa8\xa4" +
	"\xb7\xe6g\x85\xaf\x08/\xe6m\x16\x01\xeb9\xcd\xcf\x0b" +
	"\xbf,|\xe3\x88\xcd\x8d\x92\xea\xfa{W\x84_\x15n" +
	"\x15lZ\x92\xea\xfa\xb9/\x0a\x7fU=\x98\xea\x8fT" +
	"\\\xd9\x0f\x90Me\xfbC\x15\x9d\x83b\x0e,H\xba" +
	"\xac]7\xe2p\xed\xd7\xf1V\xd8\xaa\xf4\xf3\xb6\xe6E" +
	"3\x9d\xa0\xe2\xa7}\xf2\x0f\xfe\x1f\x8c\x9f\xf1\x1aKI" +
	"\x97\xf1\xa0\xd5^J\x02\xfd@\xb8\x14\xa7\xff\x94\xcc_" +
	"\x8a\x12gV\xc2V\xdc\x91w\x9e\xea\xd9%y\x06\xcf" +
	"\xac}\x17\x13O1qS\xb7\xe5{\x1d\xed\xcc\xd4\x9b" +
	"\x0a\x9b\xf5+>\x83v\xbc\xce\xb5\x7f\x07\x00\x00\xff\xff" +
	"\x07,\xa8\xc2"

func init() {
	schemas.Register(schema_85d3acc39d94e0f8,
		0xa67ef24ada1537dd,
		0xb37037e086845aa0,
		0xbd3a21c2edbb01d9,
		0xedb7a741ddfe927d)
}
