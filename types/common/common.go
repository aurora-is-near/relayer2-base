package common

import (
	"crypto/rand"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"github.com/aurora-is-near/relayer2-base/types/primitives"
	"math/big"
	"strconv"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/rpc"
)

const (
	FilterIdByteSize = 16
)

type Uinteger interface {
	~uint | ~uint16 | ~uint32 | ~uint64
}

type Integer interface {
	~int | ~int16 | ~int32 | ~int64
}

type Uint64 struct{ uint64 }

type DataVec []uint8

type Uint256 struct{ hexutil.Big }

type H256 struct{ common.Hash }

type BN64 struct{ rpc.BlockNumber }

type Address struct{ common.Address }

func (ui64 *Uint64) UnmarshalJSON(data []byte) error {
	input := strings.TrimSpace(string(data))
	if len(input) >= 2 && input[0] == '"' && input[len(input)-1] == '"' {
		if len(input) >= 3 && input[1:3] == "0x" {
			value, err := hexutil.DecodeUint64(input[1 : len(input)-1])
			if err != nil {
				return err
			}
			if value > math.MaxInt64 {
				return fmt.Errorf("block number larger than int64")
			}
			ui64.uint64 = value
		} else {
			value, err := strconv.ParseUint(input[1:len(input)-1], 10, 64)
			if err != nil {
				return err
			}
			ui64.uint64 = value
		}
	} else {
		value, err := strconv.ParseUint(input, 10, 64)
		if err != nil {
			return err
		}
		ui64.uint64 = value
	}
	return nil
}

func (ui64 *Uint64) Uint64() uint64 {
	return ui64.uint64
}

func (dv *DataVec) UnmarshalJSON(data []byte) error {
	input := strings.TrimSpace(string(data))
	if len(input) > 2 && input[0] == '"' && input[len(input)-1] == '"' {
		if len(input) >= 3 && input[1:3] == "0x" {
			buf, err := hex.DecodeString(input[3 : len(input)-1])
			if err != nil {
				return err
			}
			*dv = buf
		} else {
			buf, err := hex.DecodeString(input[1 : len(input)-1])
			if err != nil {
				return err
			}
			*dv = buf
		}
	}
	return nil
}

// Can (and must) be dramatically optimized
func (dv DataVec) MarshalText() ([]byte, error) {
	return []byte(fmt.Sprintf("0x%v", hex.EncodeToString([]byte(dv)))), nil
}

func (ui256 *Uint256) UnmarshalJSON(data []byte) error {
	input := strings.Trim(string(data), "\"")
	numPart := strings.TrimPrefix(input, "0x")
	if len(input) >= 1 {
		trimmed := strings.TrimLeft(numPart[:len(numPart)-1], "0")
		hexNum := "\"0x" + trimmed + numPart[len(numPart)-1:] + "\""
		err := ui256.Big.UnmarshalJSON([]byte(hexNum))
		if err != nil {
			return err
		}
	} else {
		return fmt.Errorf("%s not valid", string(data))
	}
	return nil
}

func (ui256 Uint256) Bytes() []byte {
	return ui256.ToInt().Bytes()
}

func (ui256 Uint256) Uint64() uint64 {
	return ui256.ToInt().Uint64()
}

func (ui256 Uint256) Text(base int) string {
	return ui256.ToInt().Text(base)
}

func (ui256 Uint256) Cmp(test Uint256) int {
	return ui256.ToInt().Cmp(test.ToInt())
}

func (ui256 Uint256) Data32() primitives.Data32 {
	return primitives.Data32FromBytes(ui256.Bytes())
}

func (n *BN64) UnmarshalJSON(data []byte) error {
	input := strings.TrimSpace(string(data))
	if len(input) >= 2 && input[0] == '"' && input[len(input)-1] == '"' {
		value, err := strconv.ParseUint(input[1:len(input)-1], 10, 64)
		if err != nil {
			err = n.BlockNumber.UnmarshalJSON(data)
			if err != nil {
				return err
			}
		} else {
			n.BlockNumber = rpc.BlockNumber(value)
		}
	} else {
		value, err := strconv.ParseUint(input, 10, 64)
		if err != nil {
			return err
		}
		n.BlockNumber = rpc.BlockNumber(value)
	}
	return nil
}

// Uint64 returns block number as *uint64.
// 	If BN64 contains following tags; Safe, Finalized, Pending, Latest it returns nil
//  If BN64 contains the Earliest tag, it returns 0
func (n *BN64) Uint64() *uint64 {
	i := n.Int64()
	if i >= 0 {
		ui := uint64(i)
		return &ui
	}
	return nil
}

// Int64 returns block number as *int64. If BN64 contains following tags; Earliest, Latest, Pending, Finalized, Safe
// it returns; 0, -1, -2, -3, -4 respectively
func (n *BN64) Int64() int64 {
	return n.BlockNumber.Int64()
}

func BN64ToInt64(n *BN64) *int64 {
	var number *int64
	if n != nil {
		bn := n.Int64()
		number = &bn
	}
	return number
}

func UintToUint64[T Uinteger](i T) Uint64 {
	return Uint64{uint64(i)}
}

func IntToUint64[T Integer](i T) Uint64 {
	return Uint64{uint64(i)}
}

// RandomUint256 returns a random Uint256 with a size of FilterIdByteSize. The 8 MSBs are BigEndian ordered Unix
// nanoseconds, the rest of the bytes are randomly generated by crypto/rand
func RandomUint256() Uint256 {
	t := make([]byte, FilterIdByteSize)
	binary.BigEndian.PutUint64(t[:8], uint64(time.Now().UnixNano()))
	_, _ = rand.Read(t[8:])
	return Uint256{Big: hexutil.Big(*big.NewInt(0).SetBytes(t))}
}

func IntToUint256[T Integer](i T) Uint256 {
	return Uint256{Big: hexutil.Big(*big.NewInt(0).SetInt64(int64(i)))}
}

func UintToUint256[T Uinteger](i T) Uint256 {
	return Uint256{Big: hexutil.Big(*big.NewInt(0).SetUint64(uint64(i)))}
}

func IntToBN64[T Integer](i T) BN64 {
	return BN64{BlockNumber: rpc.BlockNumber(i)}
}

func UintToBN64[T Uinteger](i T) BN64 {
	return BN64{BlockNumber: rpc.BlockNumber(i)}
}

func BytesToAddress(b []byte) Address {
	return Address{Address: common.BytesToAddress(b)}
}

func HexStringToAddress(s string) Address {
	return Address{Address: common.HexToAddress(s)}
}

func HexStringToHash(s string) H256 {
	return H256{Hash: common.HexToHash(s)}
}

func Uint256FromBytes(b []byte) Uint256 {
	return Uint256{Big: hexutil.Big(*big.NewInt(0).SetBytes(b))}
}

func Uint256FromHex(s string) (*Uint256, error) {
	big, err := hexutil.DecodeBig(s)
	if err != nil {
		return nil, err
	}
	return &Uint256{Big: hexutil.Big(*big)}, nil
}
